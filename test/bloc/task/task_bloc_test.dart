import 'package:flutter_test/flutter_test.dart';
import 'package:bloc_test/bloc_test.dart';
import 'package:flutter_a_c_soluciones/bloc/task/task_bloc.dart';
import 'package:flutter_a_c_soluciones/bloc/task/task_event.dart';
import 'package:flutter_a_c_soluciones/bloc/task/task_state.dart';
import 'package:flutter_a_c_soluciones/model/technical/task_model.dart';
import 'package:flutter_a_c_soluciones/model/servicio_model.dart';
import 'package:flutter_a_c_soluciones/repository/task_repository.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

import 'task_bloc_test.mocks.dart'; // Generated by build_runner

// Generate a MockTaskRepository
@GenerateMocks([TaskRepository])
void main() {
  group('TaskBloc', () {
    late MockTaskRepository mockTaskRepository;

    setUp(() {
      mockTaskRepository = MockTaskRepository();
    });

    test('initial state is TaskInitial', () {
      final taskBloc = TaskBloc(taskRepository: mockTaskRepository);
      expect(taskBloc.state, TaskInitial());
    });

    blocTest<TaskBloc, TaskState>(
      'emits [TaskLoading, TaskSuccess] when LoadTasks is added and fetching is successful',
      build: () {
        when(mockTaskRepository.getTasks(page: anyNamed('page'))).thenAnswer(
          (_) async => TaskResponse(
            tasks: [
              TaskModel(
                id: 1,
                fechaProgramada: DateTime.now(),
                duracionEstimada: 60,
                estado: 'pendiente',
                fechaCreacion: DateTime.now(),
                servicio: Servicio(
                    id: 1,
                    nombre: 'Servicio 1',
                    descripcion: 'Descripción 1',
                    estado: 'activo',
                    fechaCreacion: DateTime.now(),
                    fechaModificacion: DateTime.now()),
              ),
            ],
            hasMorePages: false,
          ),
        );
        return TaskBloc(taskRepository: mockTaskRepository);
      },
      act: (bloc) => bloc.add(LoadTasks()),
      expect: () => [
        TaskLoading(),
        isA<TaskSuccess>(),
      ],
      verify: (_) {
        verify(mockTaskRepository.getTasks(page: 1)).called(1);
      },
    );

    blocTest<TaskBloc, TaskState>(
      'emits [TaskLoading, TaskFailure] when LoadTasks is added and fetching fails',
      build: () {
        when(mockTaskRepository.getTasks(page: anyNamed('page'))).thenThrow(Exception('Failed to load tasks'));
        return TaskBloc(taskRepository: mockTaskRepository);
      },
      act: (bloc) => bloc.add(LoadTasks()),
      expect: () => [
        TaskLoading(),
        const TaskFailure(error: 'Exception: Failed to load tasks'),
      ],
      verify: (_) {
        verify(mockTaskRepository.getTasks(page: 1)).called(1);
      },
    );

    blocTest<TaskBloc, TaskState>(
      'emits [TaskLoading, TaskSuccess] when UpdateTaskStatus is added and update is successful',
      build: () {
        when(mockTaskRepository.updateTaskState(any, any)).thenAnswer((_) async => Future.value());
        when(mockTaskRepository.getTasks(page: anyNamed('page'))).thenAnswer(
          (_) async => TaskResponse(
            tasks: [
              TaskModel(
                id: 1,
                fechaProgramada: DateTime.now(),
                duracionEstimada: 60,
                estado: 'completada',
                fechaCreacion: DateTime.now(),
                servicio: Servicio(
                    id: 1,
                    nombre: 'Servicio 1',
                    descripcion: 'Descripción 1',
                    estado: 'activo',
                    fechaCreacion: DateTime.now(),
                    fechaModificacion: DateTime.now()),
              ),
            ],
            hasMorePages: false,
          ),
        );
        return TaskBloc(taskRepository: mockTaskRepository);
      },
      act: (bloc) => bloc.add(const UpdateTaskStatus(taskId: '1', newStatus: 'completada')),
      expect: () => [
        TaskLoading(),
        isA<TaskSuccess>(),
      ],
      verify: (_) {
        verify(mockTaskRepository.updateTaskState(1, 'completada')).called(1);
        verify(mockTaskRepository.getTasks(page: 1)).called(1);
      },
    );

    blocTest<TaskBloc, TaskState>(
      'emits [TaskLoading, TaskFailure] when UpdateTaskStatus is added and update fails',
      build: () {
        when(mockTaskRepository.updateTaskState(any, any)).thenThrow(Exception('Failed to update task status'));
        return TaskBloc(taskRepository: mockTaskRepository);
      },
      act: (bloc) => bloc.add(const UpdateTaskStatus(taskId: '1', newStatus: 'completada')),
      expect: () => [
        TaskLoading(),
        const TaskFailure(error: 'Exception: Failed to update task status'),
      ],
      verify: (_) {
        verify(mockTaskRepository.updateTaskState(1, 'completada')).called(1);
      },
    );
  });
}